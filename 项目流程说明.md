# Moatless Tree Search 项目流程说明

## 项目简介

Moatless Tree Search 是一个AI驱动的自动代码修复工具，专门用于解决软件bug和代码问题。它使用蒙特卡洛树搜索算法，像下棋一样智能地探索各种修复方案，找到最佳解决方案。

## 核心特点

- 🔍 **智能搜索**：使用树搜索算法系统性地探索修复方案
- 🤖 **AI驱动**：集成多个AI模型协同工作
- 📝 **代码理解**：深度分析代码结构和语义
- ✅ **自动测试**：修改后自动运行测试验证
- 📊 **可视化**：提供搜索过程的可视化界面

## 整体流程图

```
输入问题 → 环境准备 → 代码分析 → 智能搜索 → 代码修改 → 测试验证 → 输出结果
   ↓         ↓         ↓         ↓         ↓         ↓         ↓
问题描述   配置API    建立索引   树搜索    应用修改   运行测试   修复方案
代码仓库   设置环境   解析代码   选择动作   生成补丁   检查结果   搜索轨迹
```

## 详细流程步骤

### 步骤1：输入问题
你需要提供：
- 📝 问题描述（比如："修复登录功能的bug"）
- 📁 代码仓库地址
- 🧪 测试用例（可选）

### 步骤2：环境准备
设置必要的配置：
```bash
# 设置AI模型的API密钥
export OPENAI_API_KEY="your-openai-key"
export VOYAGE_API_KEY="your-voyage-key"

# 设置工作目录
export INDEX_STORE_DIR="/tmp/index_store"
export REPO_DIR="/tmp/repos"
```

### 步骤3：代码分析
系统会自动：
1. 📥 下载代码仓库
2. 🔍 分析代码结构
3. 📊 建立代码索引
4. 🎯 找到相关文件

### 步骤4：智能搜索（核心技术实现）

#### 4.1 蒙特卡洛树搜索（MCTS）算法
使用经典的MCTS四步循环：

**选择（Selection）**
```python
# 使用UCT算法选择最有希望的节点
def select_node(self, expandable_nodes):
    # UCT分数 = 利用项 + 探索项 + 奖励项 - 惩罚项
    uct_score = exploitation + exploration + bonuses - penalties
    return max(expandable_nodes, key=lambda n: n.uct_score)
```

**扩展（Expansion）**
```python
# 为选中节点生成新的动作
def expand_node(self, node):
    possible_actions = [FindClass, FindFunction, ViewCode, StringReplace, ...]
    action = agent.select_action(possible_actions)
    child_node = Node(parent=node, action=action)
    return child_node
```

**模拟（Simulation）**
```python
# 执行动作并获取结果
def simulate_action(self, node):
    observation = node.action.execute(node.file_context)
    node.observation = observation
    return observation
```

**反向传播（Backpropagation）**
```python
# 将奖励值向上传播到父节点
def backpropagate(self, node, reward):
    while node:
        node.visits += 1
        node.value += reward
        node = node.parent
```

#### 4.2 UCT节点选择策略
**核心公式：**
```
UCT(node) = exploitation + exploration + bonuses - penalties

其中：
- exploitation = reward_weight × node_reward
- exploration = exploration_weight × √(ln(parent_visits) / node_visits)
- bonuses = depth_bonus + high_value_bonus + diversity_bonus
- penalties = duplicate_penalty + finished_trajectory_penalty
```

**选择器类型：**
- **BestFirstSelector**: 选择UCT分数最高的节点
- **SoftmaxSelector**: 基于概率分布随机选择
- **LLMSelector**: 使用AI模型智能选择

#### 4.3 价值函数评估系统
**多维度评估：**
```python
def calculate_reward(self, node):
    # 代码质量评分 (0-60分)
    code_quality = self.evaluate_syntax(node) + self.evaluate_logic(node)
    
    # 测试结果评分 (0-40分)  
    test_score = self.evaluate_test_results(node)
    
    # 综合评分
    total_score = code_quality * 0.6 + test_score * 0.4
    return Reward(value=total_score)
```

**评估维度：**
- 语法正确性：检查代码是否有语法错误
- 逻辑合理性：分析代码逻辑是否符合需求
- 测试通过率：统计修改后的测试结果
- 代码风格：评估是否符合最佳实践

#### 4.4 多智能体协作
**判别器机制：**
```python
class AgentDiscriminator:
    def select_best_trajectory(self, trajectories):
        # 多个AI智能体投票选择最佳方案
        votes = {}
        for agent in self.agents:
            for traj in trajectories:
                votes[traj] = votes.get(traj, 0) + agent.evaluate(traj)
        return max(votes.keys(), key=lambda x: votes[x])
```

**反馈生成：**
- 路径建议：推荐下一步探索方向
- 错误纠正：指出常见的修复错误
- 优化建议：提供代码改进方案

#### 4.5 搜索控制机制
**终止条件：**
```python
def is_finished(self):
    return (
        self.iterations >= self.max_iterations or
        self.cost >= self.max_cost or
        self.best_reward >= self.reward_threshold or
        len(self.finished_nodes) >= self.max_finished_nodes
    )
```

**性能优化：**
- 相似度计算缓存：避免重复计算节点相似度
- 搜索状态持久化：支持断点续传
- 内存管理：清理不必要的节点数据
- 并发处理：支持多线程搜索

#### 4.6 实际代码示例
```python
# 创建搜索树
search_tree = SearchTree.create(
    message="修复登录bug",
    agent=CodingAgent(actions=[FindClass, ViewCode, StringReplace]),
    selector=BestFirstSelector(exploitation_weight=1.0),
    value_function=ValueFunction(completion_model=gpt4),
    max_iterations=50,
    reward_threshold=80.0
)

# 运行搜索
result_node = search_tree.run_search()
print(f"找到解决方案，奖励分数: {result_node.reward.value}")
```

### 步骤5：执行动作
AI可以执行多种动作：
- 🔍 **查找**：找类、函数、代码片段
- 👀 **查看**：阅读代码内容
- ✏️ **修改**：替换代码、创建文件
- 🧪 **测试**：运行测试验证
- ✅ **完成**：提交修复方案

### 步骤6：应用修改
系统会：
1. 🎯 确定需要修改的位置
2. 💡 生成修复代码
3. ✏️ 应用代码更改
4. ✅ 检查语法正确性

### 步骤7：测试验证
自动运行测试：
- 🧪 运行原有测试
- ✅ 验证修复效果
- 📊 生成测试报告

### 步骤8：输出结果
最终得到：
- 📝 修改后的代码
- 📋 修改说明
- 📊 测试结果
- 🗺️ 搜索过程轨迹
```

## 快速开始

### 安装
```bash
pip install moatless-tree-search
```

### 基本使用
```bash
# 1. 设置环境变量
export OPENAI_API_KEY="your-key"
export VOYAGE_API_KEY="your-key"

# 2. 运行代码修复
moatless-evaluate \
    --model "gpt-4o-mini" \
    --repo_base_dir /tmp/repos \
    --eval_dir "./evaluations" \
    --max_iterations 100

# 3. 查看结果
moatless-streamlit trajectory.json
```

## 结果说明

### 状态标识
运行过程中会看到不同的状态标识：
- ⭐ **已解决**：问题成功修复
- ❌ **失败**：修改无效或测试失败  
- 🟢 **找到**：找到正确的代码位置
- 🟡 **部分**：找到相关但不完整的信息

### 输出文件
- `trajectory.json`：完整的搜索过程记录
- 修改后的代码文件
- 测试结果报告

## 工作原理

这个工具就像一个会编程的AI助手：
1. 📖 **理解问题**：分析你描述的bug或需求
2. 🔍 **搜索代码**：在代码库中找到相关部分
3. 🤔 **思考方案**：像下棋一样考虑各种修复方法
4. ✏️ **尝试修改**：应用最有希望的修复方案
5. 🧪 **验证结果**：运行测试确保修复有效
6. 🔄 **持续优化**：如果不成功就尝试其他方案

## 适用场景

- 🐛 **Bug修复**：自动修复代码中的错误
- 🔧 **功能改进**：根据需求修改现有功能
- 📝 **代码重构**：优化代码结构和性能
- 🧪 **测试修复**：修复失败的测试用例